import type { Schema, Table, Column } from "./model";
import type { OwnershipTree } from "./ownershipTree";

export interface JsonSchema {
	readonly $schema: string;
	readonly type: string;
	readonly properties: Record<string, unknown>;
	readonly definitions?: Record<string, unknown>;
}

export type SchemaMode = "strict" | "insert";

export interface JsonSchemaOptions {
	/**
	 * 'insert' mode: auto-generated fields (hasDefault, isGenerated) are optional
	 * 'strict' mode: all non-nullable fields are required
	 * Default: 'insert'
	 */
	readonly mode?: SchemaMode;
}

export interface NestedJsonSchemaOptions extends JsonSchemaOptions {
	/** The ownership tree that determines nesting structure */
	readonly ownershipTree: OwnershipTree;
}

/**
 * Generate a JSON Schema from a database schema.
 * This enables autocomplete and validation in editors.
 */
export function generateJsonSchema(schema: Schema, options: JsonSchemaOptions = {}): JsonSchema {
	const mode = options.mode ?? "insert";
	const properties: Record<string, unknown> = {
		$schema: { type: "string" },
		$base: { type: "string" },
	};

	const definitions: Record<string, unknown> = {};

	for (const [tableName, table] of schema.tables) {
		// Create row schema for this table
		const rowSchema = generateRowSchema(table, mode);
		definitions[`${tableName}Row`] = rowSchema;

		// Table property is an array of rows
		properties[tableName] = {
			type: "array",
			items: { $ref: `#/definitions/${tableName}Row` },
		};
	}

	return {
		$schema: "http://json-schema.org/draft-07/schema#",
		type: "object",
		properties,
		definitions,
	};
}

function generateRowSchema(table: Table, mode: SchemaMode): Record<string, unknown> {
	const properties: Record<string, unknown> = {};
	const required: string[] = [];

	for (const column of table.columns) {
		properties[column.name] = columnToJsonSchemaType(column);

		// Determine if field is required based on mode
		const isAutoGenerated = column.hasDefault || column.isGenerated;
		if (!column.isNullable) {
			if (mode === "strict" || !isAutoGenerated) {
				required.push(column.name);
			}
		}
	}

	return {
		type: "object",
		properties,
		required: required.length > 0 ? required : undefined,
		additionalProperties: false,
	};
}

function columnToJsonSchemaType(column: Column): Record<string, unknown> {
	const baseType = pgTypeToJsonSchemaType(column.type);

	if (column.isNullable) {
		// Allow null values
		if (typeof baseType.type === "string") {
			return { ...baseType, type: [baseType.type, "null"] };
		}
		return { oneOf: [baseType, { type: "null" }] };
	}

	return baseType;
}

function pgTypeToJsonSchemaType(pgType: string): Record<string, unknown> {
	// Normalize type for comparison
	const normalizedType = pgType.toLowerCase().replace(/\(.+\)/, "").trim();

	switch (normalizedType) {
		// Numeric types
		case "smallint":
		case "integer":
		case "int":
		case "int2":
		case "int4":
		case "serial":
		case "smallserial":
			return { type: "integer" };

		case "bigint":
		case "int8":
		case "bigserial":
			// JSON can't represent bigint precisely, use string
			return { type: "string", pattern: "^-?\\d+$" };

		case "real":
		case "float4":
		case "double precision":
		case "float8":
		case "numeric":
		case "decimal":
			return { type: "number" };

		// Boolean
		case "boolean":
		case "bool":
			return { type: "boolean" };

		// Text types
		case "text":
		case "varchar":
		case "character varying":
		case "char":
		case "character":
		case "name":
			return { type: "string" };

		// UUID
		case "uuid":
			return {
				type: "string",
				format: "uuid",
				pattern: "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$",
			};

		// Date/Time types
		case "date":
			return { type: "string", format: "date" };

		case "time":
		case "time without time zone":
			return { type: "string", format: "time" };

		case "timestamp":
		case "timestamp without time zone":
		case "timestamp with time zone":
		case "timestamptz":
			return { type: "string", format: "date-time" };

		// JSON types
		case "json":
		case "jsonb":
			return {}; // Any JSON value

		// Array types
		case "text[]":
		case "varchar[]":
			return { type: "array", items: { type: "string" } };

		case "integer[]":
		case "int4[]":
			return { type: "array", items: { type: "integer" } };

		// Binary
		case "bytea":
			return { type: "string", contentEncoding: "base64" };

		// Default: treat as string
		default:
			return { type: "string" };
	}
}

/**
 * Generate a JSON Schema for nested format based on the ownership tree.
 * Only root tables appear at the top level; children are nested inline.
 */
export function generateNestedJsonSchema(
	schema: Schema,
	options: NestedJsonSchemaOptions
): JsonSchema {
	const mode = options.mode ?? "insert";
	const tree = options.ownershipTree;

	const properties: Record<string, unknown> = {
		$schema: { type: "string" },
		$connection: { type: "string" },
		$base: { type: "string" },
	};

	const definitions: Record<string, unknown> = {};

	// Generate nested row schemas for all tables
	for (const [tableName, table] of schema.tables) {
		const nestedRowSchema = generateNestedRowSchema(
			table,
			tableName,
			schema,
			tree,
			mode,
			definitions
		);
		definitions[`${tableName}NestedRow`] = nestedRowSchema;
	}

	// Only root tables appear at the top level
	for (const rootTable of tree.roots) {
		const camelName = toCamelCase(rootTable);
		properties[camelName] = {
			type: "array",
			items: { $ref: `#/definitions/${rootTable}NestedRow` },
		};
	}

	return {
		$schema: "http://json-schema.org/draft-07/schema#",
		type: "object",
		properties,
		definitions,
	};
}

function generateNestedRowSchema(
	table: Table,
	tableName: string,
	schema: Schema,
	tree: OwnershipTree,
	mode: SchemaMode,
	_definitions: Record<string, unknown>
): Record<string, unknown> {
	const properties: Record<string, unknown> = {};
	const required: string[] = [];

	// Get FK columns that should be excluded (implicit from nesting)
	const fkColumnsToExclude = new Set<string>();
	const dominantParent = tree.getDominantParent(tableName);
	if (dominantParent) {
		for (const fkCol of dominantParent.foreignKeyColumns) {
			fkColumnsToExclude.add(fkCol);
		}
	}

	// Add scalar columns (excluding FK columns to parent)
	for (const column of table.columns) {
		if (fkColumnsToExclude.has(column.name)) {
			continue; // Skip FK columns that are implicit from nesting
		}

		properties[column.name] = columnToJsonSchemaType(column);

		// Determine if field is required based on mode
		const isAutoGenerated = column.hasDefault || column.isGenerated;
		if (!column.isNullable) {
			if (mode === "strict" || !isAutoGenerated) {
				required.push(column.name);
			}
		}
	}

	// Add nested children arrays
	const children = tree.getChildren(tableName);
	for (const edge of children) {
		const camelChildName = toCamelCase(edge.childTable);
		properties[camelChildName] = {
			type: "array",
			items: { $ref: `#/definitions/${edge.childTable}NestedRow` },
		};
	}

	return {
		type: "object",
		properties,
		required: required.length > 0 ? required : undefined,
		additionalProperties: false,
	};
}

function toCamelCase(tableName: string): string {
	if (tableName.length === 0) return tableName;
	return tableName[0].toLowerCase() + tableName.slice(1);
}
